# simplex
Este solucionador de problemas de programación lineal permite ingresar un problema en español o inglés, luego lo analiza y lo resuelve. Para verlo en acción, abrir el archivo demo en un navegador.

## Para usarlo en un código propio
Usar el solucionador involucra cuatro pasos:

1. Crear un objeto lpProblem y especificar el problema de PL a resolver.
2. Fijar banderas describiendo el tipo de problema a resolver o el tipo de salida que se quiere.
3. Llamar a solve().
4. Recuperar la solución.

### Creando un lpProblem
Un nuevo objeto lpProblem se crea con
```
p = new lpProblem();
```
El constructor toma como argumento opcional, otro lpProblem para copiar. Si no se copia un objeto existente, el próximo paso es especificar el problema de PL a resolver. Esto se puede hacer de una de las siguientes maneras:

#### Especificar el problema de PL como string.

Establecer `p.problemStr` como un problema completo de PL, dado como string. El string debe tener la forma
```
Maximizar <objetivo linear> sujeto a
<restricciones lineales separadas por comas o saltos de línea>
```
`Maximizar` puede ser reemplazado por `minimizar` y puede usarse inglés también. Si se desea restringir una o más variables a valores enteros, se debe agregar lo siguiente al final del string:
```
integer <lista de variables separadas por comas>
```
Especificar expresiones lineales usando yuxtaposición para la multiplicación, es decir "2x + 3y", no "2*x+3*y". Usar "<=" y ">=" para especificar inecuaciones. La función objetivo puede ser especificada como expresión lineal o como una ecuación declarando el nombre de la función objetivo, de la forma "p = 2x + 3y". Las restricciones deben tener la forma "<expresión lineal> <= <número>" donde la igualdad también puede ser ">=" o "=". No colocar comas en los números (afecta al análisis).

#### Specify the LP problem by setting the objective and constraint properties.
- Set `p.objective` to a string representing the objective function, in the form `[max|min]imize [var =] <linear expression>`. 
- Set `p.constraints` to an array of strings representing the constraints. 
- If you are solving an integer or mixed problem, set `p.isIntegral` to `true` and set `p.integerUnknowns` to an array of unknown names that should be constrained to be integers.

### Setting flags
- `p.mode` can be set to
  - `lp_Integral` for all tableaus to have integer entries and solutions to be given as fractions
  - `lp_Fraction` for all tableaus to have fractional entries and solutions to be given as fractions
  - `lp_Decimal` for tableaus and solutions to be given using decimal notation.
- `p.showArtificialVariables` defaults to `false`, in which case the slack and surplus variables are not shown as part of solutions. If set to `true`, these variables are reported in solutions.
- `p.sigDigits` is the number of significant digits to show in decimal mode in tableau entries and solutions. It defaults to 6.
- `lp_verboseLevel` is a global variable controlling what is saved in the global string `lp_trace_string` while the problem is being solved. The default is to save nothing. If `lp_verboseLevel = lp_verbosity_tableaus`, all intermediate tableaus are saved. If `lp_verboseLevel = lp_verbosity_solutions` then all tableaus and the corresponding basic solutions are saved. The string saved is HTML, suitable to insert in a `<div>`, for example, to display on a web page.
- `lp_reportErrorsTo` is a global string controlling how errors are reported. If empty (the default), errors are not reported. If set to `"alert"`, errors cause alerts to be posted. If set to the ID of an HTML element, errors are inserted in that HTML element on the page.

### Calling `solve()`
Once the problem is set up and flags properly set, call `p.solve()`, which takes no arguments. If something is wrong with the way the problem was stated, it may throw an error, which will be a string describing the problem. This string will also be available as `p.error`.

### Retrieving the solution
After calling `p.solve()`, check `p.status`, which will be either `lp_optimal` if an optimal solution was found, or `lp_no_solution` if there was no solution. In the latter case, the property `p.message` contains a string indicating why no solution was found.

Assuming a solution was found, `p.tableaus` will be an array of all the tableaus generated by the simplex method (see Tableaus below for more information about these tableaus and methods to display them nicely) and `p.solutions` will be an array of solutions, each being an array of values for the variables. The property `p.unknowns` is an array giving the names of the unknowns in the order in which the values appear in the solutions.

To get the solutions as nicely formatted strings, call one of the following:

- `p.solutionToString()` returns a string showing the solution of the problem, using the settings of `p.showArtificialVariables` and `p.mode`.
- `p.lastSolutionToString()` is used internally to return the basic solution from the last tableau, which will not necessarily be the solution to the problem if doing integer or mixed programming.
- `p.formatUnknowns ( includeArtificalVariables )` returns an array with the names of the unknowns in the order used in the following functions. The optional argument tells whether to include the slack and surplus variables (default: `false`).
- `p.formatLastSolution ( includeArtificalVariables, mode )` returns the solution of the problem as an array of strings giving the values of the variables in the order specified in `p.unknowns`. The optional arguments tell whether to include the artificial variables (default: `false`) and the mode of solution to show (default: value of `p.mode`).
- `p.formatIntegerSolution ( includeArtificalVariables, mode )` is the corresponding routine you should use if doing integer or mixed programming.
- `p.formatLastObjectiveValue ( mode )` returns a string representing the optimal value of the objective function (for non-integer/mixed programming). The mode is optional, defaulting to `p.mode`.
- `p.formatIntegerObjectiveValue ( mode )` is the corresponding routine to use when doing integer or mixed programming.
- `p.formatSolutions ( includeArtificalVariables, mode )` is similar to `formatLastSolution`, but returns an array of basic solutions, one for each tableau generated by the simplex method.
- `p.formatObjectiveValues ( mode )` is similar to `formatLastObjectiveValue` but returns an array of all the values of the objective function for all of the tableaus.

## Tableaus
The `tableau` class extends `Array`; tableaus are always two-dimensional arrays. The 0th row contains the variable names corresponding to each column and the 0th column contains the currently active variables corresponding to each row. The actual tableau starts with index [1][1], so the matrix itself uses 1-based indexing.

There are three methods added to the `Array` class:

- `pivot ( row, col, sigDigs )` pivots on the entry in `[row][col]` and returns a new tableau. `sigDigs` is used to mitigate subtractive error and should usually be set to something large, like 13.
- `toString ( mode, sigDigs )` returns an ASCII formatted string representing the tableau. It contains no HTML tags and is suitable for showing in `<pre>` tags (but such tags are not part of the string). `mode` is one of `lp_Integral`, `lp_Fraction`, or `lp_Decimal`, and `sigDigs` is used for rounding the entries, so might be something like 6.
- `toHTML ( mode, sigDigs, params )` returns a string of HTML code representing the tableau as a `<table>`. `mode` and `sigDigs` are as for `toString`. `params` is an optional argument: If it has a `cellPadding` property, that is used to set the padding in the `<table>`  (default: 10); if it has a `lineColor` property, that is used to set the color of the lines separating the first and last rows and columns from the rest of the tableau (default: `"black"`).
